<!DOCTYPE html>
<html>
<!-- Head information -->
<head>
<meta charset='utf-8'>
<meta content='width=device-width' initial-scale='1' name='viewport'>
<!-- Always force latest IE rendering engine or request Chrome Frame -->
<!-- %meta{content: 'IE=edge,chrome=1', http-equiv: 'X-UA-Compatible'} -->
<link href='/assets/images/favicon/favicon-196x196.png' rel='icon' sizes='196x196' type='image/png'>
<link href='/assets/images/favicon/favicon-32x32.png' rel='icon' sizes='32x32' type='image/png'>
<link href='/assets/images/favicon/favicon-16x16.png' rel='icon' sizes='16x16' type='image/png'>
<link href='/assets/images/favicon/favicon-128.png' rel='icon' sizes='128x128' type='image/png'>
<link href='/assets/images/favicon/favicon.ico' rel='icon'>
<!-- Use title if it's in the page YAML frontmatter -->
<title>
Kubeless
</title>
<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css' media='screen' rel='stylesheet'>
<!-- Bitnami Design System -->
<link href='https://fonts.googleapis.com/css?family=Fira+Sans:300,400,700|Hind:300,400' media='screen' rel='stylesheet'>
<link href='//d1d5nb8vlsbujg.cloudfront.net/bitnami-ui/2.0.1/bitnami.ui.components.min.css' media='screen' rel='stylesheet'>
<link href='//d1d5nb8vlsbujg.cloudfront.net/bitnami-ui/2.0.1/bitnami.ui.min.css' media='screen' rel='stylesheet'>
<!-- Include the javascripts and the styles of the page -->
<link href="/assets/stylesheets/main.css" rel="stylesheet" />
<script src="/assets/javascripts/main.js"></script>
</head>

<!-- Main content -->
<body>
<div class='gradient-135-accent elevation-1'>
<div class='container'>
<header class='Header padding-v-big'>
<div class='row collapse-b-tablet align-center'>
<div class='col-4'>
<div class='Header__Logo'>
<a href="/"><img src="/assets/images/logo-white.svg" alt="Logo white" />
<span>
A Bitnami project
</span>
</a></div>
</div>
<div class='col-8'>
<nav class='text-r'>
<a href="/" class="margin-h-normal">Home</a>
<a href="/docs" class="margin-h-normal">Documentation</a>
<a href="https://github.com/kubeless/kubeless-ui" class="margin-h-normal">Kubeless UI</a>
<a href="https://serverless.com/framework/docs/providers/kubeless/guide/intro/" class="margin-h-normal">Serverless Plugin</a>
<a href="https://github.com/kubeless" class="margin-l-normal">GitHub</a>
</nav>
</div>
</div>
</header>

</div>
</div>
<main class='container margin-t-big'>
<div class='row collapse-b-phone-land'>
<div class='col-3'>
<h4 class='margin-t-bigger'>
<img src="/assets/images/logo-dark.svg" alt="Kubeless logo" class="float-l avatar avatar-medium" />
<div class='padding-v-small'>
Documentation
</div>
</h4>
<ul class='remove-style padding-small'>
<li>
<b>Usage</b>
</li>
<li class='margin-v-small'>
<a href="/docs/quick-start">Quick Start
</a></li>
<li class='margin-v-small'>
<a href="/docs/runtimes">Runtimes
</a></li>
<li class='margin-v-small'>
<a href="/docs/kubeless-functions">Function Characteristics
</a></li>
<li class='margin-v-small'>
<a href="/docs/triggers">Triggers
</a></li>
<li class='margin-v-small'>
<a href="/docs/pubsub-functions">PubSub Mechanism
</a></li>
<li class='margin-v-small'>
<a href="/docs/http-triggers">Expose and Secure Functions
</a></li>
<li class='margin-v-small'>
<a href="/docs/cronjob-triggers">Scheduling a function execution (CronJob)
</a></li>
<li class='margin-v-small'>
<a href="/docs/streaming-functions">Data Stream Events
</a></li>
<li class='margin-v-small'>
<a href="/docs/debug-functions">Debug Functions
</a></li>
<li class='margin-v-small'>
<a href="/docs/autoscaling">Autoscaling
</a></li>
<li class='margin-v-small'>
<a href="/docs/building-functions">Build Function Images
</a></li>
<li class='margin-v-small'>
<a href="/docs/monitoring">Monitoring
</a></li>
<li class='margin-v-small'>
<a href="/docs/advanced-function-deployment">Advanced deployment
</a></li>
<li class='margin-v-small'>
<a href="/docs/function-controller-configuration">Kubeless Configuration
</a></li>
<li class='margin-v-small'>
<a href="/docs/use-existing-kafka">Use a Custom Apache Kafka
</a></li>
<li class='margin-v-small'>
<a href="/docs/troubleshooting">Install Troubleshooting
</a></li>
<li class='padding-t-big'>
<b>Cloud Providers</b>
</li>
<li class='margin-v-small'>
<a href="/docs/kubeless-on-AKS">Azure Kubernetes Service
</a></li>
<li class='margin-v-small'>
<a href="/docs/GKE-deployment">Google Kubernetes Engine
</a></li>
<li class='padding-t-big'>
<b>Development</b>
</li>
<li class='margin-v-small'>
<a href="/docs/architecture">Architecture
</a></li>
<li class='margin-v-small'>
<a href="/docs/dev-guide">Development Guide
</a></li>
<li class='margin-v-small'>
<a href="/docs/implementing-new-runtime">Implementing a New Runtime
</a></li>
<li class='margin-v-small'>
<a href="/docs/implementing-new-trigger">Implementing a New Trigger
</a></li>
<li class='margin-v-small'>
<a href="/docs/debugging">Debugging
</a></li>
<li class='margin-v-small'>
<a href="/docs/release-flow">Release Flow
</a></li>
</ul>

</div>
<div class='col-9'>
<h1 id="kubeless-runtime-variants">Kubeless Runtime Variants</h1>

<p>By default Kubeless has support for runtimes in different states: stable and incubator. You can find the different runtimes available in this repository:</p>

<p><a href="https://github.com/kubeless/runtimes">https://github.com/kubeless/runtimes</a>.</p>

<p>You can also see the list of supported runtimes that your Kubeless installation can use executing:</p>

<pre><code class="console">$ kubeless get-server-config
INFO[0000] Current Server Config:
INFO[0000] Supported Runtimes are: python2.7, python3.4, python3.6, nodejs6, nodejs8, ruby2.3, ruby2.4, ruby2.5, php7.2, go1.10, dotnetcore2.0, java1.8, ballerina0.981.0
</code></pre>

<p>Each runtime is encapsulated in a container image. The reference to these images are injected in the Kubeless configuration.</p>

<h3 id="nodejs">NodeJS</h3>

<h4 id="example">Example</h4>

<pre><code class="js">module.exports = {
  foo: function (event, context) {
    console.log(event);
    return event.data;
  }
}
</code></pre>

<h4 id="description">Description</h4>

<p>NodeJS functions should export the desired method using <code>module.exports</code>. You can specify dependencies using a <code>package.json</code> file. It is also possible to return an object instead of a string, this object will be stringified before returning.</p>

<p>When using the Node.js runtime, it is possible to configure a <a href="https://docs.npmjs.com/misc/scope#associating-a-scope-with-a-registry">custom registry or scope</a> in case a function needs to install modules from a different source. For doing so it is necessary to set up the environment variables <em>NPM_REGISTRY</em> and <em>NPM_SCOPE</em> when deploying the function:</p>

<pre><code class="console">$ kubeless function deploy myFunction --runtime nodejs6 \
                                --env NPM_REGISTRY=http://my-registry.com \
                                --env NPM_SCOPE=@myorg \
                                --dependencies package.json \
                                --handler test.foo \
                                --from-file test.js
</code></pre>

<p>It&#39;s also possible to add another piece of configuration for your NPM file if the variable <code>NPM_CONFIG_EXTRA</code> is set. In case it&#39;s used, the build process will execute <code>npm config set $NPM_CONFIG_EXTRA</code> before installing dependencies.</p>

<p>Depending on the size of the payload sent to the NodeJS function it is possible to find the error <code>413 PayloadTooLargeError</code>. It is possible to increase this limit setting the environment variable <code>REQ_MB_LIMIT</code>. This will define the maximum size in MB that the function will accept:</p>

<pre><code class="console">$ kubeless function deploy myFunction --runtime nodejs6 \
                                --env REQ_MB_LIMIT=50 \
                                --handler test.foo \
                                --from-file test.js
</code></pre>

<p><strong>For Webpack Users</strong></p>

<p>Your webpacked functions will be <code>require()</code>-d in so your bundle should work out of the box. However, if your bundle size is approaching 1mb you should take advantage of Kubeless&#39; ability to install dependencies for you instead of bundling them all into your payload.</p>

<p>You will need to customize your webpack config to suit your own project, but below is an sample config of how to achieve this in Webpack 4.x:</p>

<p><em>webpack.config.js</em></p>

<pre><code class="js">const path = require(&quot;path&quot;);
const nodeExternals = require(&quot;webpack-node-externals&quot;);
const CopyWebpackPlugin = require(&quot;copy-webpack-plugin&quot;);

module.exports = {
  entry: {
    handlers: &quot;./handlers.js&quot;
  },
  node: {
    __filename: true,
    __dirname: true
  },
  target: &quot;node&quot;,
  // do not include dependencies in the bundle
  externals: [nodeExternals()],
  devtool: &quot;source-map&quot;,
  module: {
    rules: [
      {
        test: /\.js$/,
        use: &quot;babel-loader&quot;,
        // do not transpile the depedencies
        exclude: /node_modules/
      }
    ]
  },
  plugins: [
    // do include the project&#39;s `package.json` in the bundle
    new CopyWebpackPlugin([
      {
        from: path.join(__dirname, &quot;path&quot;, &quot;to&quot;, &quot;your&quot;, &quot;package.json&quot;),
        to: &quot;package.json&quot;
      }
    ])
  ]
};
</code></pre>

<p>Additionally, in your babel config, you can specify the transpile target to be the version of node you&#39;re using for your runtime. This is an example for Babel 7.x:</p>

<pre><code class="js">module.exports = {
  plugins: [
    &quot;@babel/plugin-proposal-class-properties&quot;,
    &quot;@babel/plugin-proposal-object-rest-spread&quot;,
    &quot;@babel/plugin-syntax-dynamic-import&quot;,
    &quot;@babel/plugin-transform-runtime&quot;
  ],
  // note the target node version here for nodejs8
  presets: [[&quot;@babel/preset-env&quot;, { targets: { node: &quot;8.10&quot; } }]]
};
</code></pre>

<h4 id="server-implementation">Server implementation</h4>

<p>For the Node.js runtime we start an <a href="http://expressjs.com">Express</a> server and we include the routes for serving the health check and exposing the monitoring metrics. Apart from that we enable <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">CORS</a> requests and <a href="https://github.com/expressjs/morgan">Morgan</a> for handling the logging in the server. Monitoring is supported if the function is synchronous or if it uses promises.</p>

<h4 id="distroless-variant">Distroless Variant</h4>

<p>There is the <a href="https://github.com/GoogleContainerTools/distroless">distroless</a> variant of the Node.js 8 runtime.<br>
The distroless Node.js runtime contains only the kubeless function and its runtime dependencies.<br>
In particular, this variant does not contain package manager, shells or any other programs which are part of a standard Linux distribution.</p>

<p>The same example Node.js function from above can then be deployed:</p>

<pre><code class="console">$ kubeless function deploy myFunction --runtime nodejs_distroless8 \
                                --env NPM_REGISTRY=http://my-registry.com \
                                --env NPM_SCOPE=@myorg \
                                --dependencies package.json \
                                --handler test.foo \
                                --from-file test.js
</code></pre>

<h4 id="cloudevents-0-1-variant">CloudEvents 0.1 Variant</h4>

<p><a href="https://cloudevents.io">CloudEvents</a> is a CNCF effort to standardize the way events are represented in the Cloud. There is a variant of the Node.js 8 runtime that is ready to receive events that follow that specification (v0.1).</p>

<p>This variant expects the header <code>application/cloudevents+json</code> in order to be parsed as a JSON cloud event or the different headers that are defined in the <a href="https://github.com/cloudevents/spec/blob/master/spec.md">specification</a> adapting them to the Kubeless function format.</p>

<p>The same example Node.js function from above can then be deployed:</p>

<pre><code class="console">$ kubeless function deploy myFunction --runtime nodejsCE8 \
                                --dependencies package.json \
                                --handler test.foo \
                                --from-file test.js
</code></pre>

<h3 id="python">Python</h3>

<h4 id="example">Example</h4>

<pre><code class="py">def handler(event, context):
    print (event)
    return event[&#39;data&#39;]
</code></pre>

<h4 id="description">Description</h4>

<p>Python functions should define the desired method. You can specify dependencies using a <code>requirements.txt</code> file.</p>

<h4 id="server-implementation">Server implementation</h4>

<p>For python we use <a href="https://bottlepy.org">Bottle</a> and we also add routes for health check and monitoring metrics.</p>

<h3 id="ruby">Ruby</h3>

<h4 id="example">Example</h4>

<pre><code class="rb">def handler(event, context)
  puts event
  JSON.generate(event[:data])
end
</code></pre>

<h4 id="description">Description</h4>

<p>Ruby functions should define the desired method. You can specify dependencies using a <code>Gemfile</code> file.</p>

<h4 id="server-implementation">Server implementation</h4>

<p>For the case of Ruby we use <a href="http://www.sinatrarb.com">Sinatra</a> as web framework and we add the routes required for the function and the health check. Monitoring is currently not supported yet for this framework. PR is welcome :-)</p>

<h3 id="go">Go</h3>

<h4 id="example">Example</h4>

<pre><code class="go">package kubeless

import &quot;github.com/kubeless/kubeless/pkg/functions&quot;

func Handler(event functions.Event, context functions.Context) (string, error) {
    return event.Data, nil
}
</code></pre>

<h4 id="description">Description</h4>

<p>Go functions require to import the package <code>github.com/kubeless/kubeless/pkg/functions</code> that is used to define the input parameters. The desired method should be exported in the package. You can specify dependencies using <a href="https://blog.golang.org/using-go-modules">go modules</a>.</p>

<h4 id="go-with-dependency-example">Go with Dependency Example</h4>

<p>This is an example of a function using the <code>github.com/sirupsen/logrus</code> dependency.</p>

<pre><code class="go">// hellowithdeps.go

package kubeless

import (
    &quot;github.com/kubeless/kubeless/pkg/functions&quot;
    &quot;github.com/sirupsen/logrus&quot;
)

// Hello sample function with dependencies
func Hello(event functions.Event, context functions.Context) (string, error) {
    logrus.Info(event.Data)
    return &quot;Hello world!&quot;, nil
}
</code></pre>

<pre><code class="go">//go.mod

module function

go 1.14

require (
    github.com/sirupsen/logrus v1.6.0
)
</code></pre>

<pre><code class="bash">kubeless function deploy get-go-deps --runtime go1.14 --handler hellowithdeps.Hello --from-file hellowithdeps.go --dependencies go.mod
</code></pre>

<h4 id="server-implementation">Server implementation</h4>

<p>The Go HTTP server doesn&#39;t include any framework since the native packages includes enough functionality to fit our needs. Since there is not a standard package that manages server logs that functionality is implemented in the same server. It is also required to implement the <code>ResponseWriter</code> interface in order to retrieve the Status Code of the response. Apart from that we enable <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">CORS</a> to accept any request.</p>

<h4 id="debugging-compilation">Debugging compilation</h4>

<p>If there is an error during the compilation of a function, the error message will be dumped to the termination log. If you see that the pod is crashed in a init container:</p>

<pre><code class="console">NAME                      READY     STATUS                  RESTARTS   AGE
get-go-6774465f95-x55lw   0/1       Init:CrashLoopBackOff   1          1m
</code></pre>

<p>That can mean that the compilation failed. You can obtain the compilation logs executing:</p>

<pre><code class="console">$ kubectl get pod -l function=get-go -o yaml
...
    - containerID: docker://253fb677da4c3106780d8be225eeb5abf934a961af0d64168afe98159e0338c0
      image: andresmgot/go-init:1.10
      lastState:
        terminated:
          containerID: docker://253fb677da4c3106780d8be225eeb5abf934a961af0d64168afe98159e0338c0
          exitCode: 2
          finishedAt: 2018-04-06T09:01:16Z
          message: |
            # kubeless
            /go/src/kubeless/handler.go:6:1: syntax error: non-declaration statement outside function body
...
</code></pre>

<p>You can see there that there is a syntax error in the line 6 of the function. You can also retrieve the same information with this one-liner:</p>

<pre><code class="console">$ kubectl get pod -l function=get-go -o go-template=&quot;{{range .items}}{{range .status.initContainerStatuses}}{{.lastState.terminated.message}}{{end}}{{end}}&quot;

&lt;no value&gt;# kubeless
/go/src/kubeless/handler.go:6:1: syntax error: non-declaration statement outside function body
</code></pre>

<h4 id="timeout-handling">Timeout handling</h4>

<p>One peculiarity of the Go runtime is that the user has a <code>Context</code> object as part of the <code>Event.Extensions</code> parameter. This can be used to handle timeouts in the function. For example:</p>

<pre><code class="go">func Foo(event functions.Event, context functions.Context) (string, error) {
  select {
  case &lt;-event.Extensions.Context.Done():
    return &quot;&quot;, nil
  case &lt;-time.After(5 * time.Second):
  }
  return &quot;Function returned after 5 seconds&quot;, nil
}
</code></pre>

<p>If the function above has a timeout smaller than 5 seconds it will exit and the code after the <code>select{}</code> won&#39;t be executed.</p>

<h3 id="java">Java</h3>

<h4 id="example">Example</h4>

<pre><code class="java">package io.kubeless;

import io.kubeless.Event;
import io.kubeless.Context;

public class Foo {
    public String foo(io.kubeless.Event event, io.kubeless.Context context) {
        return &quot;Hello world!&quot;;
    }
}
</code></pre>

<h4 id="description">Description</h4>

<p>Java functions must use <code>io.kubeless</code> as package and should import both <code>io.kubeless.Event</code> and <code>io.kubeless.Context</code> packages. Function should be made part of a public class and should have a function signature that takes <code>Event</code> and <code>Context</code> as inputs and produces <code>String</code> output. Once you have Java function meeting the requirements it can be deployed with Kubeless as below. Where handler part <code>--handler Foo.foo</code> takes <code>Classname.Methodname</code> format.</p>

<pre><code class="cmd">  kubeless function deploy get-java --runtime java1.8 --handler Foo.foo --from-file Foo.java
</code></pre>

<p>Kubeless supports Java functions with dependencies. Kubeless uses Maven for both dependency management and building user given functions. Users are expected to provide function dependencies expresses in Maven pom.xml format.</p>

<p>Lets take Java function with dependency on <code>org.joda.time.LocalTime</code>.</p>

<pre><code class="java">package io.kubeless;

import io.kubeless.Event;
import io.kubeless.Context;

import org.joda.time.LocalTime;

public class Hello {
    public String sayHello(io.kubeless.Event event, io.kubeless.Context context) {
        System.out.println(event.Data);
        LocalTime currentTime = new LocalTime();
        return &quot;Hello world! Current local time is: &quot; + currentTime;
    }
}
</code></pre>

<h4 id="dependencies">Dependencies</h4>

<p>Dependencies are expressed through standard Maven pom.xml file format as below.</p>

<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;artifactId&gt;function&lt;/artifactId&gt;
  &lt;name&gt;function&lt;/name&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;dependencies&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;joda-time&lt;/groupId&gt;
       &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
       &lt;version&gt;2.9.2&lt;/version&gt;
     &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;io.kubeless&lt;/groupId&gt;
          &lt;artifactId&gt;params&lt;/artifactId&gt;
          &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;parent&gt;
    &lt;groupId&gt;io.kubeless&lt;/groupId&gt;
    &lt;artifactId&gt;kubeless&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
&lt;/project&gt;
</code></pre>

<p>Notice the reference to <code>kubeless</code> parent pom module and dependency on <code>params</code> artifact. pom.xml should also use <code>function</code> as artifact ID.</p>

<p>Once you have Java function with dependencies and pom.xml file expressing the dependencies Java function can be deployed with Kubeless as below.</p>

<pre><code class="cmd">    kubeless function deploy get-java-deps --runtime java1.8 --handler Hello.sayHello --from-file java/HelloWithDeps.java --dependencies java/pom.xml
</code></pre>

<blockquote>
<p>Note: Maven command line arguments can be set using environment flag <code>--env</code>. For instance proxy details can be set as</p>
</blockquote>

<pre><code class="cmd">    kubeless function deploy get-java --runtime java1.8 --handler Foo.foo --from-file Foo.java --env MAVEN_OPTS=&#39;-DproxySet=true -DproxyHost=&lt;proxy_host&gt; -DproxyPort=&lt;proxy_port&gt;&#39;
</code></pre>

<h3 id="net-core-c">.NET Core (C#)</h3>

<h4 id="example">Example</h4>

<pre><code class="csharp">using System;
using Kubeless.Functions;

public class module
{
    public object handler(Event k8Event, Context k8Context)
    {
        return k8Event.Data;
    }
}
</code></pre>

<p>Deploy it using the following command:<br>
<code>bash<br>
kubeless function deploy helloget --from-file helloget.cs --handler module.handler --runtime dotnetcore2.0<br>
</code></p>

<h4 id="description">Description</h4>

<p>To get started using .NET Core with kubeless, you should use the following commands:</p>

<pre><code class="bash">dotnet new library
dotnet add package Kubeless.Functions
</code></pre>

<p>.NET Core (C#) functions supports returns for any primitive or complex type. The method signature needs to have first an <code>Kubeless.Functions.Event</code> followed by an <code>Kubeless.Functions.Context</code>. The models are definied as it follows:</p>

<pre><code class="csharp">public class Context
{
    public string ModuleName { get; }
    public string FunctionName { get; }
    public string FunctionPort { get; }
    public string Timeout { get; }
    public string Runtime { get; }
    public string MemoryLimit { get; }
}
</code></pre>

<pre><code class="csharp">public class Event
{
    public object Data { get; }
    public string EventId { get; }
    public string EventType { get; }
    public string EventTime { get; }
    public string EventNamespace { get; }
    public Extensions Extensions { get; }
}
</code></pre>

<h4 id="dependencies">Dependencies</h4>

<p>Dependencies are handled in <code>.csproj</code> extension. You can use the regular <code>.csproj</code> file outputted by the <code>dotnet new library</code> command.</p>

<pre><code class="xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;Kubeless.Functions&quot; Version=&quot;0.1.1&quot; /&gt;
    &lt;PackageReference Include=&quot;YamlDotNet&quot; Version=&quot;4.3.1&quot; /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;

</code></pre>

<p>The runtime already have built-in the package <code>Kubeless.Functions:0.1.1</code>, necessary to all functions - so you don&#39;t need to include that. Then, if you have a function which does not need any external references than <code>Kubeless.Functions</code>, you don&#39;t need to even send the <code>--dependencies</code> flag on kubeless cli.</p>

<p>You can deploy them using the command:</p>

<pre><code class="bash">kubeless function deploy fibonacci --from-file fibonacci.cs --handler module.handler --dependencies fibonacci.csproj --runtime dotnetcore2.0
</code></pre>

<h5 id="nuget-config"><code>nuget.config</code></h5>

<p>If you happen to be using custom nuget repositories through a <code>nuget.config</code> file, you&#39;ll need to include the file along with the code inside a <code>.zip</code> file and then you can deploy the function with the <code>nuget.config</code> using the command:</p>

<pre><code class="bash">kubeless function deploy custom-deps --from-file custom-deps.zip --handler module.handler --dependencies custom-deps.csproj --runtime dotnetcore2.0
</code></pre>

<h3 id="ballerina">Ballerina</h3>

<h4 id="example">Example</h4>

<pre><code class="ballerina">import kubeless/kubeless;
import ballerina/io;

public function foo(kubeless:Event event, kubeless:Context context) returns (string|error) {
    io:println(event);
    io:println(context);
    return &quot;Hello Ballerina&quot;;
}

</code></pre>

<h4 id="description">Description</h4>

<p>The Ballerina functions should import the package <code>kubeless/kubeless</code>. This <a href="https://central.ballerina.io/kubeless/kubeless">package</a> contains two types <code>Event</code> and <code>Context</code>.</p>

<pre><code class="console">$ kubeless function deploy foo
    --runtime ballerina0.981.0
    --from-file foo.bal
    --handler foo.foo
</code></pre>

<p>When using the Ballerina runtime, it is possible to provide a configuration via <code>kubeless.toml</code> file. The values in kubeless.toml file are available for the function. The function(.bal file) and conf file should be in the same directory.<br>
The zip file containing both files should be passed to the Kubeless CLI.</p>

<pre><code class="console">foo
├── hellowithconf.bal
└── kubeless.toml

$ zip -r -j foo.zip foo/

$ kubeless function deploy foo
      --runtime ballerina0.981.0
      --from-file foo.zip
      --handler hellowithconf.foo
</code></pre>

<h4 id="server-implementation">Server implementation</h4>

<p>For the Ballerina runtime we start a <a href="../docker/runtime/ballerina/kubeless_run.tpl.bal">Ballerina HTTP server</a> with two resources, &#39;/&#39; and &#39;/healthz&#39;.</p>

<h2 id="use-a-custom-runtime">Use a custom runtime</h2>

<p>The Kubeless configuration defines a set of default container images per supported runtime variant.</p>

<p>These default container images can be configured via Kubernetes environment variables on the Kubeless controller&#39;s deployment container. Or modifying the <code>kubeless-config</code> ConfigMap that is deployed along with the Kubeless controller. For more information about how to modify the Kubeless configuration check <a href="https://kubeless.io/docs/function-controller-configuration/">this guide</a>.</p>

<p>Apart than changing the configuration, it is possible to use a custom runtime specifying the image that the function will use. If you are interested in developing a new runtime from scratch (i.e. for a new language) you should follow <a href="https://kubeless.io/docs/implementing-new-runtime/">this guide</a>. In the linked guide you can find the requirements that a new runtime should fulfill and how you can submit new runtimes to the Kubeless project.</p>

<p>In any case, if you want to use one of the existing runtimes but you want to modify it to support a specific feature you can easily do that. The first thing is to modify the files in <a href="https://github.com/kubeless/kubeless/tree/master/docker/runtime"><code>docker/runtime</code></a> folder. For example, if we want to add the <code>lodash</code> <code>npm</code> module globally in the NodeJS runtime we can modify its <a href="https://github.com/kubeless/kubeless/tree/master/docker/runtime/nodejs/Dockerfile.8">Dockerfile</a>:</p>

<pre><code class="patch">...
  RUN apt-get update &amp;&amp; apt-get install git
+ RUN npm install -g lodash

...
</code></pre>

<p>Now we can use the Makefile in the folder to generate the base image:</p>

<pre><code class="console">▶ make build8
docker build -t kubeless/nodejs:8$RUNTIME_TAG_MODIFIER -f Dockerfile.8 .
Sending build context to Docker daemon  7.059MB
Step 1/10 : FROM node:8
 ---&gt; 55791187f71c
Step 2/10 : RUN apt-get update &amp;&amp;  apt-get install git
 ---&gt; Using cache
 ---&gt; 70f1565e9353
Step 3/10 : RUN npm install -g lodash
 ---&gt; Running in 03602280a37d
+ lodash@4.17.10
added 1 package in 1.369s
...
Successfully built d68eccb2568b
Successfully tagged kubeless/nodejs:8
</code></pre>

<p>We can now retag the image and push it using a different account:</p>

<pre><code class="console">▶ docker tag kubeless/nodejs:8 andresmgot/nodejs-with-lodash:8

▶ docker push andresmgot/nodejs-with-lodash:8
The push refers to repository [docker.io/andresmgot/nodejs-with-lodash]
5a9aabfdd819: Pushed
...
8: digest: sha256:dfd26034130e5aae5a3db7b3df969649c44c3f7d1168bee7c4e1e6e7e75726d7 size: 3261
</code></pre>

<p>Finally in order to use this new flavor we need to add it to the Kubeless config. We will just copy the official <code>nodejs</code> runtime and rename it to reflect the changes:</p>

<pre><code class="console">▶ kubectl edit -n kubeless configmap kubeless-config
# Add the following object within the &quot;runtime-images&quot; array
#      {
#        &quot;ID&quot;: &quot;nodejsWithLodash&quot;,
#        &quot;compiled&quot;: false,
#        &quot;versions&quot;: [
#          {
#            &quot;name&quot;: &quot;node8&quot;,
#            &quot;version&quot;: &quot;8&quot;,
#            &quot;runtimeImage&quot;: &quot;andresmgot/nodejs-with-lodash:8&quot;,
#            &quot;initImage&quot;: &quot;node:8&quot;
#          }
#        ],
#        &quot;depName&quot;: &quot;package.json&quot;,
#        &quot;fileNameSuffix&quot;: &quot;.js&quot;
#      },
configmap &quot;kubeless-config&quot; edited
</code></pre>

<blockquote>
<p>NOTE: You should just use lowercase and uppercase characters for the ID. The runtime selection is made concatenating the runtime ID and the version (i.e. nodejsWithLodash8 for this example)</p>
</blockquote>

<p>The last step in order to deploy a function with the new runtime is to restart the Kubeless controller pod:</p>

<pre><code class="console">▶ kubectl delete pods -n kubeless -l kubeless=controller
pod &quot;kubeless-controller-manager-67fbc78f6d-w2vnk&quot; deleted

▶ kubeless function deploy my-nodejs-func --runtime nodejsWithLodash8 --handler helloget.foo --from-file examples/nodejs/helloget.js
INFO[0000] Deploying function...
INFO[0000] Function my-nodejs-func submitted for deployment
INFO[0000] Check the deployment status executing &#39;kubeless function ls my-nodejs-func&#39;

# Wait for the function pod to be deployed
▶ kubectl exec -it my-nodejs-func-55546fcf68-78fpz -- npm list -g | grep lodash
+-- lodash@4.17.10
</code></pre>

<h2 id="use-a-custom-livenessprobe">Use a custom livenessProbe</h2>

<p>One can use kubeless-config to override the default liveness probe. By default, the liveness probe is <code>http-get</code> this can be overriden by providing the livenessprobe info in <code>kubeless-confg</code> under <code>runtime-images</code>. It has been implemented in such a way that each runtime can have its own liveness probe info. To use custom liveness probe paste the following info in <code>runtime-images</code>:</p>

<pre><code class="json">&quot;version&quot;: [],
&quot;livenessProbeInfo&quot;: {
  &quot;exec&quot;: {
    &quot;command&quot;: [
      &quot;curl&quot;,
      &quot;-f&quot;,
      &quot;http://localhost:8080/healthz&quot;
    ]
  },
  &quot;initialDelaySeconds&quot;: 5,
  &quot;periodSeconds&quot;: 5,
  &quot;failureThreshold&quot;: 3,
  &quot;timeoutSeconds&quot;: 30
},
&quot;depname&quot;: &quot;&quot;
</code></pre>

</div>
</div>
</main>
<div class='margin-t-giant'>
<div class='Footer'>
<div class='container padding-h-big padding-v-bigger'>
<div class='Footer__Border padding-t-big'>
<div class='row collapse-b-phone-land'>
<div class='col-6'>
<h4 class='inverse margin-reset'>
<img src="/assets/images/logo-white.svg" alt="Kubeless logo" class="Footer__Logo" />
</h4>
<p class='type-color-iron type-small margin-reset'>
© Kubeless 2021 | All Rights Reserved.
</p>
</div>
<div class='col-6 text-r'>
<a href="https://github.com/kubeless" class="margin-l-small"><img src="/assets/images/social/github.svg" alt="See the Github Profile of the Kubeless project" />
</a></div>
</div>
</div>
</div>
</div>

</div>
</body>
</html>
<script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js'></script>
<script>
  hljs.initHighlightingOnLoad();
</script>
